
# -*- coding: utf-8 -*-
#
# -----------------------------------------------------------------------------
# Driver for the control of Weather sensors.
#
# Author:   Luca Rosignoli
#
# -----------------------------------------------------------------------------
# Edit History:
#   Generated by Python Interface Generator for AlpycaDevice
#
#
from time import sleep, time, strftime, localtime
from logging import Logger
from threading import Thread, Event
import adafruit_dht as dht
import board
import adafruit_mlx90614
import RPi.GPIO as GPIO

GPIO.setmode(GPIO.BCM)


class WeatherDevice:

    def __init__(self, logger: Logger = None):

        self.__class__.name: str = 'WeatherDevice'
        self.__class__.logger = logger
        self.__class__._connected: bool = False
        self.__class__._isOperating: bool = False
        self.__class__._stop = Event()
        
        try:
            self.__class__._i2c = board.I2C()
            self.__class__._dht11 = dht.DHT11(board.D17, use_pulseio=False)
            self.__class__._mlx = adafruit_mlx90614.MLX90614(self.__class__._i2c)
            self.__class__._rainpin = 18 #25
            GPIO.setup(self.__class__._rainpin, GPIO.IN)
        except Exception as e:
            print(e)
            self.__class__._i2c = None
            self.__class__._dht11 = None
            self.__class__._mlx = None
        
        
        self.__class__._sensors = {
            'CloudCover':{'Description': 'Cloud sensor',
                           'Value':0.0},
            'DewPoint':{'Description': 'Dewpoint calculation',
                           'Value':0.0},
            'Humidity':{'Description': 'Hudimity sensor',
                           'Value':0.0},
            'SkyTemp':{'Description': 'Sky Temperature sensor',
                           'Value':0.0},
            'OutsideTemp':{'Description': 'Outside Temperature sensor',
                           'Value':0.0},
            'InsideTemp':{'Description': 'Inside Temperature sensor',
                           'Value':0.0},
            'RainRate':{'Description': 'Raindrop sensor',
                           'Value':0.0}
            }
        
        # Device properties
        self.__class__._avperiod: float = 5.0
        self.__class__._readout_time: float = None
        self.__class__._refresh: bool = False

    
    #
    # Guarded properties
    #
    
    @property
    def connected(self) -> bool:
        res = self.__class__._connected
        return res
    
    @connected.setter
    def connected(self, connected: bool):
        
        if not self.__class__._connected:
            self.__class__._connected = connected
            
        elif connected and not self.__class__._isOperating:
            self.start()

    @property
    def avperiod(self) -> float:
        res = self.__class__._avperiod
        return res
    
    @avperiod.setter
    def avperiod(self, period: float):
        self.__class__._avperiod = period
    
    @property
    def readout_time(self) -> float:
        res = self.__class__._readout_time
        return res
    
    @property
    def refresh(self) -> bool:
        res = self.__class__._refresh
        return res
    
    @refresh.setter
    def refresh(self, key: bool):
        self.__class__._refresh = key

    
    #    
    # GET, SET METHOD (need more than self parameter)
    #

    def get_sensor_value(self, name) -> float:
        res = self.__class__._sensors[name]['Value']
        return res
    
    def get_sensor_description(self, name) -> str:
        res = self.__class__._sensors[name]['Description']
        return res    
    
    #
    # RETRIEVING VALUES FROM SENSOR
    #

    def read_sensor(self) -> float:
        
        try:
            
            temp = self.__class__._dht11.temperature
            hum = self.__class__._dht11.humidity
            t_a = self.__class__._mlx.ambient_temperature
            t_o = self.__class__._mlx.object_temperature
            k = 0.5
#             print('Readed')
            cl = (t_a/t_o)*k*100.0 # TODO: Need to calibrate the k costant!!! 
            dw = temp - ((100.0-hum)/5.0)
            if GPIO.input(self.__class__._rainpin):
                rn = 0.0
            else:
                rn = 1.0
            
            readout = [cl, dw, hum, t_o, t_a, temp, rn]
            for key, rd in zip(self.__class__._sensors.keys(), readout):
                self.__class__._sensors[key]['Value'] = rd
            
            self.__class__._readout_time = strftime('%d-%m-%YT%H:%M:%S', localtime())
            
        except Exception as e:
            pass

    def _loop_thread(self):
        self.__class__._isOperating = True
        while not self.__class__._stop.is_set():
            self.read_sensor()
            sleep(self.__class__._avperiod)

    def start(self):
        if self.__class__._isOperating:
            return
        elif self.__class__._stop.is_set():
            self.__class__._stop.clear()
        Thread(target=self._loop_thread, name='weather_measurements_loop').start()
        
    def stop(self):
        self.__class__._stop.set()
        self.__class__._isOperating = False